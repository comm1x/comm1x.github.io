---
layout: post
title: "Как дизайнить поддерживаемые ответы в REST-API"
description: "Как дизайнить поддерживаемые ответы в REST-API"
tags: [rest, aggregate, roots, api]
---

В этой статье я расскажу об одном способе дизайна ответов в REST-API, который позволяет
строить простые и понятные ответы, а также легко их поддерживать и расширять.

## Проблема 

В API, как правило, много разных сущностей. И хотя REST говорит, что один ресурс должен отвечать за одну сущность,
мы вынуждены объединять запросы, чтобы все это работало побыстрее. 

Допустим у нас есть сущности `User` и `Car`, и есть __запрос 1: Получить список людей с любимыми автомобилями__.
Ответ мог бы выглядеть примерно так:

```json
[
    {
      "id": 1,
      "name": "John Watson",
      "favorite_cars": [
        {
          "id": 1000,
          "name": "Ford Focus"
        },
        {
          "id": 1001,
          "name": "Toyota Corolla"
        }
      ] 
    }
]
```

А еще у нас есть админка, в которой администратор управляет пользователями, и ему нужен просто список `User`.
Он делает __запрос 2: Получить список людей для админки__
Ответ для администратора мог бы выглядеть так:

```json
[
    {
      "id": 1,
      "name": "John Watson"
    },
    {
      "id": 2,
      "name": "Sherlock Holmes"
    }
]
```

#### Опциональные поля

И вот первая проблема с которой мы сталкиваемся - это опциональные поля сущности `User`. Работая с такой сущностью,
мы должны всегда держать в голове контекст того, где мы находимся, и есть ли сейчас поле `favorite_cars` в `user` или нет.

Непонятно как в таком случае имплементировать функцию получения первой favorite-машины:
```js
function getFirstFavoriteCarOf(user) {
    return user.favorite_cars.first()  // Корректный ли это код?
}
```

Правильно ли написана функция? Нужно читать значение из поля `favorite_cars` или идти за ним в API по сети?
Сигнатура функции не дает ответов на эти вопросы.

Покуда мы будем гарантировать, что функция `getFirstFavoriteCarOf(user)` будет выполняться только на юзерах
из запроса 1, и не будет вызываться на юзерах из запроса 2, то этот код будет работать корректно. Если правило нарушится,
код упадет. И это условие говорит о том, что фактически мы получили две разных сущности `User`.

#### Update сущности с опциональными полями

А как обновлять сущность `User`? Мы изменили имя юзера и хотим отправить новую сущность на сервер. Что отправлять в
поле `favorite_cars`? Его вообще отправлять не хочется, потому что оно вероятно изменяется отдельными методами в API.
Но не послать его мы не можем, потому что объявили его в сущности `User`.

Возможные решения: либо как-то игнорировать поле, либо определять новую сущность для обновления без `favorite_cars`
и других связанных сущностей. 

#### Передача сущностей с many-many

Вторая проблема - это деградация связей many-many до one-many.

У одного пользователя может быть несколько любимых авто. Один авто может нравиться нескольким людям. Вот она many-many.

Но в примере с запросом 1, мы упростили отношение до one-many. И теперь чтобы вывести список людей, которым нравится
Toyota Corolla, нам нужно читать структуру `user => cars` изнутри-наружу и строить новую структуру `car => users`.
А если мы захотим построить список машин, то выясним, что в наш список не попадут те машины, которые не являются любимыми
ни для одного юзера.

Кому-то покажется, что решение - добавить еще один API endpoint, который будет возвращать вывернутую структуру `car => users`,
но в итоге это приведет к тому, что если мы захотим получить все many-many, мы будет вынуждены делать 2 запроса:
получать все `one-many` и затем все `many-one`.

Не то, чтобы это технически невозможно. Возможно. Но на мой взгляд, это выглядит коряво.


## Решение - Aggregate Roots

Наверняка, многие читатели догадались как организовать правильно передачу `many-many`: нужно отдельно передавать сущности А,
отдельно сущности B, и отдельно связи.

Ответ мог бы выглядеть так:
```json
{
  "users": [
    {
      "id": 1,
      "name": "John Watson"
    }, {
      "id": 2,
      "name": "Sherlock Holmes"
    }
  ],
  "cars": [
    {
      "id": 1000,
      "name": "Ford Focus"
    }, {
      "id": 1001,
      "name": "Toyota Corolla"
    }
  ],
  "favorite_relations": [
    {
      "user_id": 1,
      "car_id": 1000
    }, {
      "user_id": 2,
      "car_id": 1001
    }
  ]
}
```

Что у нас кардинально поменялось:

1. Во-первых, корнем объекта у нас стал не список, а _объект-агрегат_<sup>[1](#link1)</sup>, который содержит в себе
все другие сущности.

2. Во-вторых, все внутренние сущности не содержат в себе других сущностей. Таким образом, решилась проблема опциональных
полей. Каждая сущность теперь __знает только про себя__ и содержит только id других сущностей. Теперь эту самостоятельную
сущность можно спокойно посылать в update-запросах, например.

3. В-третьих, т.к. у нас теперь связи лежат отдельно, мы можем используя их, построить любые структуры из данных, которые будут
при этом гарантированно полными.

Еще один пример более полного агрегат ответа _"Список магазинов с со всеми данными"_:

```js
{
    "shops": [...],
    
    // каждый продукт хранит id родительского магазина, по которому можно сгруппировать
    "products": [{ shop_id: 1, ... }, ...], 
    
    // отзывы хранят id юзера, который оставил отзыв и id продукта
    "reviews": [{ product_id: 1, user_id: 2, ...}, ...] 
    "users": [...],
    "purchases": [...],
    "cities": [...]
}
```

Еще один важный момент:

| **При использовании агрегатов, бэкенд снимает с себя всю ответственность за построение предварительной структуры, которая была бы удобна клиенту.**

И это хорошо, потому что подготовка удобной для клиента структуры - это на самом деле _ответственность клиента_, а не бэкенда.
В некоторых вырожденных случаях разработки, когда есть строго один бэк и он пишется под одного клиента, подготовка
данных на бэке может быть целесообрана, но все же это не универсальный подход. Ведь это ведет к перемешиванию ответственностей,
и бэк начинает зависеть от клиента, что в общем-то не очень здорово (эдакий шаг в сторону RPC).

| **Использование агрегатов снимает с бэка вопрос "В каком виде передать данные" и бэк думает только над тем "Что передать".**

Единственный пункт, который все же можно оставить в ответственности бэка - это передача [словарей](https://en.wikipedia.org/wiki/Associative_array) вместо списков.
Возможно иногда есть смысл передавать не список, а уже построенный словарь с id в качестве ключей.    
Например, в последнем примере в `cities` можно было бы передать словарь `city_id => City`  
Или в `reviews` построить словарь `product_id => List<Review>` 

#### Эволюция структуры ответа

Рост уровня вложенности сущностей, влечет за собой рост сложности ответа.
При уровне вложенности = 5, уже сложно говорить о переиспользуемости и универсальности ответа. В случае с агрегатами,
мы можем добавлять сколько угодно разных сущностей в агрегат, и структура ответа будет оставаться простой.

Эволюция структуры в агрегате - это просто добавление или удаление поля.
В "классических ответах" в случае когда сущности связаны по схеме: `A -> B -> C` проблематично будет убрать B из схемы,
не убрав С.

#### Отсутствие дублирования сущностей

Не то, чтобы это прям очень важно, но все же как плюс стоит отметить. В агрегатах, при правильном дизайне, полностью 
исключаются дублирования сущностей, что ведет к уменьшению размера ответа.

#### Недостатки подхода

У такого решения есть масса плюсов, но не обошлось и без недостатков. При таких ответах бэкенд снимает с себя ответственность
за формирование такой структуры, которая была бы удобна клиенту. И это означает, что иногда агрегат придется подготавливать
на клиенте и формировать нужные структуры, с нужными индексами (например список `products` группировать по `shop_id`).

## Пояснения

<a name="link1">[1]</a> Термин `Aggregate` я заимствовал из DDD. В этом паттерне агрегаты выполняют схожую роль.

Из [Martin Fowler - DDD Aggregate](https://martinfowler.com/bliki/DDD_Aggregate.html):

> A DDD aggregate is a cluster of domain objects that can be treated as a single unit.
> 
> Aggregates are the basic element of transfer of data storage - you request to load or save whole aggregates.

Справка по [Data Transfer Object](http://design-pattern.ru/patterns/data-transfer-object.html)     