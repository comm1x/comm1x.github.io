---
layout: post
title: "Универсальный протокол ошибок для REST-API"
description: "Универсальный протокол ошибок для REST-API"
tags: [rest, error, protocol, api]
---

<figure class="center">
	<img src="/images/phone-error.jpeg" alt="">
</figure>

Передача ошибок - не такая простая штука как может показаться. Рассмотрим пример с запросом
на создание юзера с двумя полями:

```
PUT /v01/user

{
  "email": "john@test.com",
  "password": "123456"
}
```

Какие гипотетические ошибки тут могут возникнуть?

1. **Ошибка поля** email: такой email уже используется, email не корректен, email находится
в запрещенной зоне
2. **Ошибка поля** password: слишком короткий, слишком длинный, слишком простой и т.д.
3. **Ошибка создания**: вам разрешено создавать не более 5 юзеров, а вы пытаетесь создать 6й
4. Ресурс `/v01/user` уже устарел, используйте `/v02/user`
(может возникнуть в мобильном приложении которое давно не обновлялось; для веба не актуально)
5. У вас недостаточно прав для обращения к этому ресурсу (может возникнуть при работе с 
устаревшими клиентами в мобильных приложениях; т.е. ресурс был открыт, но потом закрыли)
6. Auth-токен под которым вы совершаете запрос - устарел, невалиден, вас забанили, юзера удалили
и все остальные ошибки аутентификации
7. На сервере ведутся технические работы
8. Какие-то **непредусмотренные** клиентом ошибки


Как видно, на один запрос мы можем получить самые разные ошибки, или **комбинацию из них.**


> Например, вместе получить ошибки 1, 2, 3, 8 в одном ответе - вполне реальная ситуация.  
> На клиентах этот набор ошибок будет также обрабатываться в разных местах. Ошибки 1-3 - это
> валидационные ошибки, они должны быть обработаны недалеко от формы. Ошибки 4-8 в некотором смысле
> глобальные, т.е. могут прийти в ответ на любой запрос, и обработчик на них также должен быть один
> глобальный.

### Решение

Я считаю хорошей практикой представлять ошибки в виде полиморфного списка.
Мы используем определенное поле, например `type`, которое будет отвечать за тип ошибки, а остальной
набор полей будет зависеть от `type`.

Все ошибки из примера в одном ответе могли бы выглядеть так:

```
HTTP/1.1 422 Unprocessable Entity

[
    {
        "type": "form-field-error",
        "field": "email",
        "id": "email-already-exists",
        "message": "Such email already exists"
    },
    {
        "type": "form-field-error",
        "field": "password",
        "id": "password-too-weak",
        "message": "Password too weak"
    },
    {
        "type": "form-error",
        "id": "too-many-users",
        "message": "Unable to create one more user."
    },
    {
        "type": "global-error",
        "id": "forbidden",
        "message": "Not allowed"
    },
    {
        "type": "global-error",
        "id": "jwt-token-expired",
        "message": "Your auth-token expired. Please, login again"
    },
    {
        "type": "global-error",
        "id": "you-won-million",
        "message": "You won 1 million dollars!"
    },
]
```

Для каждого набора полей используется свой `type`.

Поле `id` - это уникальный id ошибки, на который можно подвязываться при обработке.
Для отображения ошибки можно использовать **свое сообщение** или поле `message`, если оно вам подходит.

### Типы ошибок

Можно выделить 3 типа ошибок, каждый из которых будет представлен отдельным классом.
1. `FormFieldError(id, field, message)` ошибки валидации форм
2. `FormError(id, message)` ошибки самих форм
3. `GlobalError(id, message)` глобальные ошибки, которые могут прилететь на любой запрос

`GlobalError` и `FormError` хотя и одинаковые по структуре, но логически должны обрабатываться в разных
местах. Поэтому они разделены на разные классы. 

### Глобальные ошибки с отдельным статусом

Хотя я и стараюсь минимизировать использование отдельных HTTP-статусов для ошибок, но некоторые ошибки
просто необходимо выносить в отдельный статус.

#### API Deprecated

Эта ошибка на бэкенде может генерироваться как в рантайме, так и в веб-сервере
(устарел весь сервер или домен). Поэтому эту ошибку лучше вынести в отдельный статус, например:

```
410 Gone
```

#### Server under maintenance

Для проведения работ на сервере неплохо бы также иметь отдельный статус, чтобы веб-сервер
отдавал его клиентам и не пропускал запросы в сам бэкенд. При этом на клиенте важно отличать
ситуации "ведутся технические работы" от "сервер недоступен".
В первом случае можно просто попросить пользователя подождать и попробовать чуть позже. Во втором -
нужно бить тревогу, слать репорты и вообще это непредусмотренное поведение, таких ситуаций нужно
избегать. Поэтому для этого кейса используем:

```
503 Service unavailable
```

Состояние **Сервер недоступен** в данном случае будет выражаться либо TCP-ошибкой `Сonnection refused`,
либо `502 Bad Gateway`, когда веб-сервер не видит бэкенд.

# FAQ

#### **Q: Почему бы просто не использовать разные http-статусы для ошибок?**

Http-статусов ограниченное количество, сто клиентских (400-499) и сто серверных (500-599).
У этих статусов уже есть предопределенный смысл, который не всегда может подойти. И иногда может
случится, что вам нужно уточнить статус, например 401 Unauthorized может быть потому что нет токена,
или токен протух - две разных ошибки. 

#### **Q: Зачем надо закладываться на непредусмотренные ошибки? Я же всегда могу посмотреть список ошибок в документации, и все их обработать.**

Если у вас возникает такой вопрос, то вероятно вы писали только веб-клиенты.
У REST-API также могут быть мобильные клиенты, которые особенны тем, что как только вы их релизнули - 
это пожизненно ваш клиент (потому что он может не обновиться никогда). И если вы не хотите, чтобы
ваши клиенты получили падающий апп, потому что вы после релиза добавили еще одну проверку 
на бэкенде - то нужно закладываться на ошибки в будущем, нужен гибкий протокол передачи ошибок 
и гибкий обработчик.

#### **Q: Зачем 2 поля type и id? Нельзя ли использовать одно поле?**

`type` - нужен для маппинга ошибок в классы. Т.е. сейчас нам нужно всего 3 класса (по одному для
каждого `type`). Если мапить по `id`, то кол-во классов будет слишком большим.

#### **Q: Message в ошибке на английском, как его перевести на язык клиента?**

Передавать в заголовке язык клиента, чтобы `message` переводил бэкенд. 


## Итого

* `200 OK` если все ок
* `410 Gone` API Deprecated
* `503 Service unavailable` На сервере ведутся работы
* `422 Unprocessable Entity` Для списка полиморфных ошибок

Любые другие статусы считаются как непредвиденное поведение, и на них нужно реагировать тревогой
и репортами в багтрекер. 

Минималистично, детерминировано.