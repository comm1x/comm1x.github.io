---
layout: post
title: "Универсальный протокол ошибок для REST-API"
description: "Универсальный протокол ошибок для REST-API"
tags: [rest, error, protocol, api]
---

<figure class="center">
	<img src="/images/phone-error.jpeg" alt="">
</figure>

Передача ошибок - не такая простая штука как может показаться. Рассмотрим пример с запросом
на создание юзера с двумя полями:

```
PUT /v01/user

{
  "email": "john@test.com",
  "password": "123456"
}
```

Какие гипотетические ошибки тут могут возникнуть?

1. **Ошибка поля** email: такой email уже используется, email не корректен, email находится
в запрещенной зоне
2. **Ошибка поля** password: слишком короткий, слишком длинный, слишком простой и т.д.
3. **Ошибка создания**: вам разрешено создавать не более 5 юзеров, а вы пытаетесь создать 6й
4. Ресурс `/v01/user` уже устарел, используйте `/v02/user`
(может возникнуть в мобильном приложении которое давно не обновлялось; для веба не актуально)
5. У вас недостаточно прав для обращения к этому ресурсу (может возникнуть при работе с 
устаревшими клиентами в мобильных приложениях; т.е. ресурс был открыт, но потом закрыли)
6. Auth-токен под которым вы совершаете запрос - устарел, невалиден, вас забанили, юзера удалили
и все остальные ошибки аутентификации
7. На сервере ведутся технические работы
8. Какие-то **непредусмотренные** клиентом ошибки


Как видно, на один запрос мы можем получить самые разные ошибки, или **комбинацию из них.**


> Например, вместе получить ошибки 1, 2, 3, 8 в одном ответе - вполне реальная ситуация.  
> На клиентах этот набор ошибок будет также обрабатываться в разных местах. Ошибки 1-3 - это
> валидационные ошибки, они должны быть обработаны недалеко от формы. Ошибки 4-8 в некотором смысле
> глобальные, т.е. могут прийти в ответ на любой запрос, и обработчик на них также должен быть один
> глобальный.

### Решение - полиморфный список ошибок

Мы используем определенное поле `type` (тип ошибки), а остальной
набор полей зависит от `type`.

Все ошибки из примера в одном ответе могли бы выглядеть так:

```
HTTP/1.1 422 Unprocessable Entity

[
    {
        "type": "form-field-error",
        "field": "email",
        "id": "email-already-exists",
        "message": "Such email already exists"
    },
    {
        "type": "form-field-error",
        "field": "password",
        "id": "password-too-weak",
        "message": "Password too weak"
    },
    {
        "type": "form-error",
        "id": "too-many-users",
        "message": "Unable to create one more user."
    },
    {
        "type": "global-error",
        "id": "forbidden",
        "message": "Not allowed"
    },
    {
        "type": "global-error",
        "id": "jwt-token-expired",
        "message": "Your auth-token expired. Please, login again"
    },
    {
        "type": "global-error",
        "id": "you-won-million",
        "message": "You won 1 million dollars!"
    },
]
```

Для каждого набора полей используется свой `type`.

Поле `id` - это уникальный id ошибки, на который можно подвязываться при обработке.
Для отображения ошибки можно использовать **свое сообщение** или поле `message`, если оно вам подходит.

### 3 типа ошибок

Можно выделить 3 типа ошибок, каждый из которых будет представлен отдельным классом.
1. `FormFieldError(id, field, message)` ошибки валидации форм
2. `FormError(id, message)` ошибки самих форм или эндпоинтов
3. `GlobalError(id, message)` глобальные ошибки, которые могут прилететь на любой запрос

`GlobalError` и `FormError` хотя и одинаковые по структуре, но разные по контексту 
(приложение и эндпоинт). Документируются они в разных местах и обрабатываются в разных места.
Поэтому они разделены на разные классы. 

### Глобальные ошибки с отдельным статусом

Хотя я и стараюсь минимизировать использование отдельных HTTP-статусов для ошибок, но некоторые ошибки
просто необходимо выносить в отдельный статус.

#### API Deprecated

Эта ошибка на бэкенде может генерироваться как в рантайме, так и в веб-сервере
(устарел весь сервер или домен). Поэтому эту ошибку лучше вынести в отдельный статус, например:

```
410 Gone
```

#### Server under maintenance

Для проведения работ на сервере неплохо бы также иметь отдельный статус, чтобы веб-сервер
отдавал его клиентам и не пропускал запросы в сам бэкенд. При этом на клиенте важно отличать
ситуации "ведутся технические работы" от "сервер недоступен".
В первом случае можно просто попросить пользователя подождать и попробовать чуть позже. Во втором -
нужно бить тревогу, слать репорты и вообще это непредусмотренное поведение, таких ситуаций нужно
избегать. Поэтому для этого кейса используем:

```
503 Service unavailable
```

Состояние **Сервер недоступен** в данном случае будет выражаться либо TCP-ошибкой `Сonnection refused`,
либо `502 Bad Gateway`, когда веб-сервер не видит бэкенд.

# FAQ

#### **Q: Почему бы просто не использовать разные http-статусы для ошибок?**

Возможностей http-статусов недостаточно.

Http-статусов ограниченное количество, сто клиентских (400-499) и сто серверных (500-599).
У этих статусов уже есть предопределенный смысл, который не всегда может подойти.

401 Unauthorized можно прийти когда:
1. access-токен протух: клиент должен его обновить и после заново послать запрос
2. нет токена: клиент должен показать попап сообщение о том, что
"Функционал недоступен для гостей, залогиньтесь"
3. access-токен принадлежит несуществующему юзеру: клиенту надо забыть невалидный токен и 
попросить юзера залогиниться
4. пользователь забанен: показать соответствующее сообщение

Гибкости http-статусов недостаточно чтобы выразить эти кейсы. Поэтому лучше от них нужно отказаться, и
использовать свои идентификаторы ошибок, без привязки к статусам.

#### **Q: Как передавать кастомные параметры в ошибке?**

Просто класть в тело ошибки. Но желательно гарантировать, что для одного id ошибки всегда приходит
один и тот же набор полей.

Пример ошибки со смыслом: "Нельзя еще раз выслать код, т.к. он уже был отправлен,
попробуйте через 35 секунд".

```json
[
  {
      "type": "form-error",
      "id": "sms-already-sent",
      "message": "Sms code already sent",
      "tryAfter": 35
  }
]
```

#### **Q: Чем отличается form-error от global-error?**

Отличаются контекстом. Структурно они одинаковые.

`global-error` - это глобальные ошибки для всего приложения, они могут прийти в ответ на любой запрос,
любого эндпоинта. Контекст - все приложение.

`form-error` - это ошибка только одного эндпоинта. Контекст - один эндпоинт.

В документации к эндпоинту вы будете описывать все `form-field-error` и `form-error`, которые он
может вернуть. А `global-error` по умолчанию присутствуют в каждом эндпоинте, так что они
описываются в документации ко всему API, а не отдельному эндпоинту.

На клиенте `form-error` и `global-error` обрабатываются в разных местах. `form-error` - должны
обрабатываться там, откуда был сделан запрос. А для `global-error` должны быть общие глобальные
обработчики ошибок. 

#### **Q: Можно ли объединить form-error и global-error?**

Технически - да. Каких-то больших проблем это не должно повлечь. Но я за смысловую строгость,
поэтому не советую так делать.

#### **Q: Зачем надо закладываться на непредусмотренные ошибки? Я же всегда могу посмотреть список ошибок в документации, и все их обработать.**

Потому что есть мобильные клиенты, которые не хотят обновляться. И нужно стараться добиваться
**корректного поведения** всех мобильных клиентов, включая **всех устаревших**.

Под корректным я имею в виду - если у вас приложение устарело, оно должно показывать сообщение, что оно
устарело, а не падать.

Мобильные клиенты особенны тем, что как только вы их релизнули - 
это пожизненно ваш клиент (потому что он может не обновиться никогда). И если вы не хотите, чтобы
ваши клиенты получили падающий апп, потому что вы после релиза добавили еще одну проверку 
на бэкенде - то нужно закладываться на ошибки в будущем, нужен гибкий протокол передачи ошибок 
и гибкий обработчик.

#### **Q: Зачем 2 поля type и id? Нельзя ли использовать одно поле?**

`type` - нужен для маппинга ошибок в классы. Т.е. сейчас нам нужно всего 3 класса (по одному для
каждого `type`). Если мапить по `id`, то кол-во классов будет слишком большим.

#### **Q: Message в ошибке на английском, как его перевести на язык клиента?**

Передавать в заголовке язык клиента, чтобы `message` переводил бэкенд. 

#### **Q: Что отвечать бэкенду, если клиент прислал некорректный запрос или произошла ошибка?**

То же, что и раньше - 400 Bad Request или 500 Internal Server Error.

Через полиморфный список нужно выражать только предусмотренные штатные ошибки.
Нештатные ситуации и ошибки нужно выражать привычным способом.

Подразумевается, что если клиент прислал некорректный запрос и сервер ответил 400 Bad Request, то
это нештатная ситуация, ее не должно было возникнуть, это ошибка разработчиков. Клиент должен на нее 
показать ошибку и отправить репорт в багтрекер.


## Итого

* `200 OK` если все ок
* `410 Gone` API Deprecated
* `503 Service unavailable` На сервере ведутся работы
* `422 Unprocessable Entity` Для списка полиморфных ошибок

Любые другие статусы считаются как непредвиденное поведение, и на них нужно реагировать тревогой
и репортами в багтрекер. 

Минималистично, детерминировано.