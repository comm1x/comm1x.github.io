---
layout: post
title: "Советы по правильному написанию запросов к SQL-базе"
description: "Советы по правильному написанию запросов к SQL-базе"
tags: [sql, mysql, tips]
---

Немного советов о том, как правильно писать запросы к SQL-базе. И немного про ORM.

## 0. Очевидное

Используй только параметризованые запросы и всегда ставь внешние ключи там где они необходимы.

## 1. Не бойся делать SELECT

Если у тебя просто по id выбираются записи из базы - это ок. 
Не нужно бояться сделать один лишний селект к базе.

Такие запросы база может переваривать тысячами, и от одного лишнего ей не будет ничего. 
```mysql
SELECT * FROM user WHERE id=:id
```

## 2. Избегай цикличных запросов

Казалось бы, притча во языцах, но нет-нет да столкнешься на проекте с цикличными запросами.
Особенно часто это касается связанных сущностей.
Вместо
```mysql
SELECT * FROM user WHERE id=1
SELECT * FROM user WHERE id=2
SELECT * FROM user WHERE id=3
```

у тебя должен быть всего один запрос

```mysql
SELECT * FROM user WHERE id IN (1,2,3)
```

Если у тебя сложная ORM и она так не умеет, выброси ее и напиши свой запрос/репозиторий руками. 

## 3. Не оптимизируй джойнами

Серьезно, джойны - это не оптимизация. Они не облегчают запросы. __Джойны нужны для выборки
кастомного набора столбцов__, которые находятся в разных таблицах или вычисляются на лету 
(чаще всего это статистика, и все что около нее). Например, нужно выбрать сколько у пользователя машин:

```mysql
SELECT user.id, COUNT(car.id) AS cars_count FROM user
JOIN car ON car.user_id = user.id
GROUP BY user.id
```

Кроме как джойном мы больше это сделать не можем. Поэтому джойн.

Еще один пример, когда нужен джойн - это __оптимизация транзитивных условий__. Например, нам нужно узнать
текущую страну пользователя, а для этого нужно выбрать его город, регион, и потом страну.

```mysql
SELECT country.* FROM user
JOIN city ON city.id = user.city_id
JOIN region ON region.id = city.region_id
JOIN country ON country.id = region.country_id
WHERE user.id=:id
```

В данном случае, сделать "4 селекта без джойна" или "1 но с джойнами" выходит примерно одинаково дешево.
Но один запрос иметь поприятнее, согласись.

## 4. Один запрос - один тип сущности

Один запрос должен возвращать один тип сущности. Не надо заставлять свою базу и ORM вернуть одновременно 2
типа сущности. Обычно, это приводит к неоправданным джойнам, дублированию данных в ответах.

Пример возврата двух типов сущностей:
 
```mysql
SELECT user.*, city.* FROM user
JOIN city ON city.id = user.city_id
WHERE user.id IN (<ids>)
```

Данный запрос породит дублирование данных, которое нужно будет как-то разруливать в твоей ORM.
Плюс за джойн база тебе спасибо не скажет.

А должно быть так:
```mysql
SELECT * FROM user WHERE id IN (<ids>)
SELECT * FROM city WHERE id IN (<ids>)
```
Мы делаем селект юзеров. Затем собираем необходимый список id городов, и по ним делаем второй селект.
Просто и прозрачно.

## 5. Не бойся работать руками

Этот пункт - логическое продолжение 4го пункта (или даже повторение).

Нам нужно выбрать большое количество связанных сущностей.
Вопрос: какое оптимальное количество запросов нам для этого нужно? Ответ простой - по одному запросу на каждый тип
сущности, ни больше ни меньше.

Пример: нужно выбрать Страны с Областями, с Городами и с Улицами. Для того, чтобы это сделать
нужно ровно 4 простых селекта:

```mysql
SELECT * FROM country
SELECT * FROM region WHERE id IN (<ids>)
SELECT * FROM city WHERE id IN (<ids>)
SELECT * FROM street WHERE id IN (<ids>)
```

Но сложность в том, что между этими запросами вам нужно вычислить промежуточные id-шники на клиенте.
И текущий пункт о том, что не нужно бояться этого делать.
Если вдруг, ваша ORM не умеет автоматически вычислять промежуточные id - выбросите ее и напишите свой
тонкий слой с простыми запросами.

Пример кода на гипотетическом js:

```js
countries = countriesRepo.selectAll()

regionIds = countries.map(it => it.id)
regions = regionsRepo.selectAll(regionIds)

cityIds = regions.map(it => it.id)
cities = citiesRepo.selectAll(cityIds)

streetIds = cities.map(it => it.id)
streets = streetsRepo.selectAll(streetIds)
```

Все данные есть, можно делать с ними теперь что угодно.
Промежуточная манипуляция это совсем не страшно.
Лучше отправить простой запрос к базе, и потом на клиенте все разложить как надо, чем
пытаться делать запрос-франкенштейн, чтобы он вернул тебе данные в каком-то удобном для тебя виде, или
потому что так работает твоя ORM. 

## Вместо заключения

Иногда программисты ошибочно возводят в абсолют разные технологии.
Технология объявляется чем-то идеальным, а все что выходит за ее рамки применимости - считается 
чем-то дурным и неправильным. ORM - не исключение, и я бы хотел развеять эту догматичность.

Большинство ORM не умеют решать проблему N+1 (цикличные запросы при получении связанных сущностей).
Часто ORM джойнят запросы, пытаяюсь получить много сущностей из одного запроса. Когда эти
пункты накладываются в проде под нагрузкой, ты внезапно обнаруживаешь, что твой прод начинает отвечать
по 10 секунд, а счет выполненных запросов измеряется в тысячах.  

Следуй вышеперечисленным пунктам. Если ORM тебе мешает - не бойся ее обходить.
И твоя база будет атлетична и быстра.  